// base.conf - base configuration file for YPilot.

// NOTE: configuration files use JavaScript-like syntax, but should not be simply evaluated as JS; they should be parsed and interpreted more restrictively for security purposes

registerJSType("boolean");
registerJSType("number");
registerJSType("string");
registerJSClass("SVGGeometryElement");
registerJSClass("AudioScheduledSourceNode");
registerJSClass("Vec2");
registerJSClass("Agent");
registerJSClass("Space");
registerJSClass("Component");
registerJSClass("Event");

/* component definitions
 * format:
 * defineComponent("ComponentName", ["OtherComponents", "RequiredTo", "BePresentOn", "TheSameEntity"], {
 *   "propertyName": propertyType
 * });
 * Property types are mostly strings naming other component/entity types or
 * fundamental types, but can also be ["Array", propertyType] for an Array
 * whose elements must be of that type.
 */

defineComponent("Named", [], {
  "name": "string"
});
// nominal subtype of the intersection of the listed supertypes
defineComponent("Type", ["Named"], {
  "supertypes": ["Array", "Type"]
});
// this identifies the nominal type of the entity it is on, independent of the
// types of its components
defineComponent("Typed", [], {
  "type": "Type"
});
// physical size (radius?)
defineComponent("Sized", [], {
  "size": "number"
});
defineComponent("Located", [], {
  "space": "Space",
  "position": "Vec2"
});
// solid things participate in collisions
defineComponent("Solid", ["Sized", "Located"], {
  "shape": ["Array", "Vec2"]
});
defineComponent("Oriented", [], {
  "orientation": "number" // angle in radians
});
// can be moved
defineComponent("Mobile", ["Located", "Oriented"], {
  "velocity": "Vec2",
  "angularVelocity": "number" // radians per tick
});
// keeps going when forced to move
defineComponent("Inertial", ["Mobile"], {
  "mass": "number",
  "force": "Vec2"
});
// can do things at the request of an Agent
defineComponent("Animate", [], {
  "agents": ["Array", "Agent"]
});
// can hold a single (type of) thing at a time
defineComponent("Slot", [], {
  "contents": "Any",
  "capacity": "number",
  // restrictions on the type of thing this slot can hold; the arrays of types here are treated as unions; may use special types "Any" (top) or "No" (bottom)
  "allow": ["Array", "Type"],
  "deny": ["Array", "Type"]
});
// can hold several different things in different slots
defineComponent("Holding", [], {
  "slots": ["Array", "Slot"]
});
// can move itself using thrusters and fuel
defineComponent("Motile", ["Inertial", "Animate", "Holding" /* fuel */], {
  "turnSpeed": "number",
  "thrustForce": "number",
  "turnDirection": "number", // -1=CW, 1=CCW, 0=not turning
  "isThrusting": "boolean"
});
// can be damaged and destroyed
defineComponent("Mortal", [], {
  "hitPoints": "number"
});
// can damage other things
defineComponent("Damaging", [], {
  "hitPoints": "number"
  // TODO? agent allow/deny lists, for e.g. friendly fire detection
});
// expires after some time has elapsed (distinct from hitpoints)
defineComponent("Fleeting", [], {
  "timeToLive": "number"
});
// comes back after being destroyed, after a delay
defineComponent("Respawning", ["Mortal"], {
  "timeToRespawn": "number"
});
// can fill a slot with multiple "copies" of itself (not actually copied)
defineComponent("Stackable", ["Located"], {
  "currentStackSize": "number",
  "maximumStackSize": "number"
});
// can be seen by at least some Agents (allow/deny work similarly to those in Slot)
defineComponent("Visible", ["Located"], {
  "graphics": ["Array", "SVGGeometryElement"],
  "allow": ["Array", "Agent"],
  "deny": ["Array", "Agent"]
});
// can be heard by at least some agents (ditto)
defineComponent("Audible", [/*Located?*/], {
  "audio": ["Array", "AudioScheduledSourceNode"],
  "allow": ["Array", "Agent"],
  "deny": ["Array", "Agent"]
});
// NOTE: originally the above two shared a "Perceptible" component, but
// sometimes we might want to be seen and not heard, or vice versa, or seen by
// different agents than those who hear

/* Entity type definitions
 * format:
 * defineEntityType(name, [supertypes, and, component, types]);
 */
defineEntityType("Wall", ["Solid", "Visible"]);
defineEntityType("Ship", ["Mortal", "Motile", "Solid", "Visible"]);
defineEntityType("Bullet", ["Damaging", "Fleeting", "Mobile", "Solid", "Visible"]);
defineEntityType("Item", ["Fleeting", "Mobile", "Solid", "Visible"]);

/* TODO define event-driven rules for how entities are created/modified (both adding/removing components and modifying values within them)/destroyed
 */
